import rospy
import time
import math
import numpy as np
from geometry_msgs.msg import Twist
from geometry_msgs.msg import PoseStamped
from scipy.spatial.transform import Rotation as R

MAX_SAFE_LIN_VELOCITY = 0.25
MAX_SAFE_ANG_VELOCITY = 2
MIN_SAFE_LIN_VELOCITY = .2

class ros_control_node():
    '''
    Class for interfacing with ROS nodes.
    Publishes to: cmd_vel
    Subscribes to: pose
    Services Called: teleport_absolute, teleport_relative, kill, and clear
    '''

    def __init__(self):
        '''
        Create the message passing objects. Create handles for all services to be used for killing, spawning, and relocating turtles. Finally, kill the default turtle
        and create the publisher and subscriber for the "my_turtle" turtle that gets generated with the "spawn_turtle" function call.
        '''
        # initialize ros publisher and subscriber
        rospy.init_node("control_alg_node", anonymous=True)
        self.optitrack_msg = PoseStamped()
        self.twist = Twist()
        self.time = time.time_ns()
        self.timestep = 0

        # for handling rotation matrix in get_current_state
        self.r = 0

        # these handles will be the interface to ROS for our turtlebot
        self.vel_publisher = rospy.Publisher('/mobile_base/commands/velocity', Twist, queue_size=10)
        self.optitrack_receive = rospy.Subscriber('raph_enu', PoseStamped, self.ros_pose_callback)
        time.sleep(1)

    def ros_pose_callback(self, data):
        '''
        Callback function listening in the ROS system for updates to the Turtlebot's position. Saves the data to this class's pose calculation.
        '''
        self.optitrack_msg = data

    def euler_from_quaternion(self, x, y, z, w):
        """
        Convert a quaternion into euler angles (roll, pitch, yaw)
        roll is rotation around x in radians (counterclockwise)
        pitch is rotation around y in radians (counterclockwise)
        yaw is rotation around z in radians (counterclockwise)
        """
        t0 = +2.0 * (w * x + y * z)
        t1 = +1.0 - 2.0 * (x * x + y * y)
        roll_x = math.atan2(t0, t1)
     
        t2 = +2.0 * (w * y - z * x)
        t2 = +1.0 if t2 > +1.0 else t2
        t2 = -1.0 if t2 < -1.0 else t2
        pitch_y = math.asin(t2)
     
        t3 = +2.0 * (w * z + x * y)
        t4 = +1.0 - 2.0 * (y * y + z * z)
        yaw_z = math.atan2(t3, t4)
     
        return roll_x, pitch_y, yaw_z # in radians

    def get_current_state(self):
        '''
        Return the turtlebot's last known position generated by the ros_pose_callback in a list with the format: [x, y, theta].
        '''
        pos_x = self.optitrack_msg.pose.position.x
        pos_y = self.optitrack_msg.pose.position.y
        ori_x = self.optitrack_msg.pose.orientation.x
        ori_y = self.optitrack_msg.pose.orientation.y
        ori_z = self.optitrack_msg.pose.orientation.z
        ori_w = self.optitrack_msg.pose.orientation.w
        return [pos_x, pos_y, self.euler_from_quaternion(ori_x, ori_y, ori_z, ori_w)[2]]

    def publish_cmd_vel(self):
        '''
        Assuming the object attribute self.twist has been updated with the new desired trajectory (velocity and angle), publish that velocity through the Publisher
        that talks through the topic cmd_vel.
        '''
        self.vel_publisher.publish(self.twist)

    def generate_twist_msg(self, components_dot):
        '''
        Updates the object's "twist" attribute to contain a new desired trajectory. Only the turtlebot's linear "x" velocity is updated to fit with the dynamics used in
        the controller. This "x" velocity moves the turtlebot forward in the direction it faces. Only the turtlebot's angular "z" is updated (for the turtlebot this is
        the only component that matters).
        '''
        if components_dot[1] > MAX_SAFE_LIN_VELOCITY:
            self.twist.linear.x = MAX_SAFE_LIN_VELOCITY
        elif components_dot[1] < MIN_SAFE_LIN_VELOCITY:
            self.twist.linear.x = MIN_SAFE_LIN_VELOCITY
        else:
            self.twist.linear.x = components_dot[1]
        self.twist.linear.y = 0
        self.twist.linear.z = 0

        self.twist.angular.x = 0
        self.twist.angular.y = 0
        if components_dot[0] > MAX_SAFE_ANG_VELOCITY:
            self.twist.angular.z = MAX_SAFE_ANG_VELOCITY
        elif components_dot[0] < -MAX_SAFE_ANG_VELOCITY:
            self.twist.linear.z = -MAX_SAFE_ANG_VELOCITY
        else:
            self.twist.angular.z = components_dot[0] # check this... angular data probs radians when read from controller.
            # ^^ is the angular velocity being created by the controller in the same form as the turtlebot requires? I think turtlebot agrees with the state...
        print('geometry msg: ', [self.twist.linear.x, self.twist.linear.y, self.twist.linear.z], [self.twist.angular.x, self.twist.angular.y, self.twist.angular.z])