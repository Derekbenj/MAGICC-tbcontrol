import rospy
import time
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import Twist
from turtlesim.srv import Kill
from turtlesim.srv import TeleportAbsolute, TeleportRelative, Spawn
from std_srvs.srv import Empty

class ros_control_node():
    '''
    Class for interfacing with ROS nodes.
    Publishes to: cmd_vel
    Subscribes to: pose
    Services Called: teleport_absolute, teleport_relative, kill, and clear
    '''

    def __init__(self):
        '''
        Create the message passing objects. Create handles for all services to be used for killing, spawning, and relocating turtles. Finally, kill the default turtle
        and create the publisher and subscriber for the "my_turtle" turtle that gets generated with the "spawn_turtle" function call.
        '''
        # initialize ros publisher and subscriber
        rospy.init_node("control_alg_node", anonymous=True)
        self.pose = PoseStamped()
        self.twist = Twist()
        self.time = time.time_ns()
        self.timestep = 0

        # these handles will be the interface to ROS for our turtlebot
        self.cmd_vel_pub = rospy.Publisher('/my_turtle/cmd_vel', Twist, queue_size=10)
        self.pose_sub = rospy.Subscriber('raph_enu', PoseStamped, self.ros_pose_callback)

    def ros_pose_callback(self, data):
        '''
        Callback function listening in the ROS system for updates to the Turtlebot's position. Saves the data to this class's pose calculation.
        '''
        self.pose = data

    def get_current_state(self):
        '''
        Return the turtlebot's last known position generated by the ros_pose_callback in a list with the format: [x, y, theta].
        '''
        return [self.pose.x, self.pose.y, self.pose.theta]

    def publish_cmd_vel(self):
        '''
        Assuming the object attribute self.twist has been updated with the new desired trajectory (velocity and angle), publish that velocity through the Publisher
        that talks through the topic cmd_vel.
        '''
        self.cmd_vel_pub.publish(self.twist)

    def generate_twist_msg(self, components_dot):
        '''
        Updates the object's "twist" attribute to contain a new desired trajectory. Only the turtlebot's linear "x" velocity is updated to fit with the dynamics used in
        the controller. This "x" velocity moves the turtlebot forward in the direction it faces. Only the turtlebot's angular "z" is updated (for the turtlebot this is
        the only component that matters).
        '''
        self.twist.linear.x = components_dot[1]
        self.twist.linear.y = 0
        self.twist.linear.z = 0

        self.twist.angular.x = 0
        self.twist.angular.y = 0
        self.twist.angular.z = components_dot[0] # check this... angular data probs radians when read from controller.
        # ^^ is the angular velocity being created by the controller in the same form as the turtlebot requires? I think turtlebot agrees with the state...
        print('geometry msg: ', [self.twist.linear.x, self.twist.linear.y, self.twist.linear.z], [self.twist.angular.x, self.twist.angular.y, self.twist.angular.z])